<!-- <script>
  //@ts-nocheck
  // Get the canvas element and its context
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  let rect = {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
    isDragging: false,
  };

  // Function to draw the rectangle
  function drawRect() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
    ctx.fillStyle = "#222";
    ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
  }

  // Initial draw
  drawRect();

  // Mouse events for dragging
  let offsetX, offsetY;

  canvas.addEventListener("mousedown", function (event) {
    const rectCanvas = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rectCanvas.left;
    const mouseY = event.clientY - rectCanvas.top;

    console.log({ rectCanvas, mouseX, mouseY, rect });

    // Check if the mouse is inside the rectangle
    if (mouseX >= rect.x && mouseX <= rect.x + rect.width && mouseY >= rect.y && mouseY <= rect.y + rect.height) {
      console.log("setting dragging");
      rect.isDragging = true;
      // Calculate the offset between the mouse position and the rectangle's position
      offsetX = mouseX - rect.x;
      offsetY = mouseY - rect.y;
    }
  });

  canvas.addEventListener("mousemove", function (event) {
    if (rect.isDragging) {
      const rectCanvas = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rectCanvas.left;
      const mouseY = event.clientY - rectCanvas.top;

      // Update the rectangle's position relative to the mouse
      rect.x = mouseX - offsetX;
      rect.y = mouseY - offsetY;

      // Redraw the rectangle in the new position
      drawRect();
    }
  });

  canvas.addEventListener("mouseup", function () {
    rect.isDragging = false; // Stop dragging when the mouse is released
  });

  canvas.addEventListener("mouseleave", function () {
    rect.isDragging = false; // Stop dragging if the mouse leaves the canvas
  });
</script> -->
<script is:inline src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script is:inline>
  // Create scene
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  // Create camera
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 6;

  // Create renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);

  const main = document.querySelector("main");
  main.appendChild(renderer.domElement);

  // Create geometry (sphere)
  const geometry = new THREE.SphereGeometry(1, 64, 64);

  // Create material (standard material with some metallic/roughness properties)
  const material = new THREE.MeshStandardMaterial({
    color: 0xff7729,
    roughness: 0.3,
  });

  // Create mesh (the blob object)
  const blob = new THREE.Mesh(geometry, material);
  scene.add(blob);

  // Add light to the scene
  const pointLight = new THREE.PointLight(0xffffff, 1);
  pointLight.position.set(5, 5, 5);
  scene.add(pointLight);

  const ambientLight = new THREE.AmbientLight(0x404040); // soft light
  scene.add(ambientLight);

  // Add noise to the geometry to create a blobby effect
  function addNoiseToBlob() {
    const time = performance.now() * 0.001; // Get time-based noise
    const positions = geometry.attributes.position.array;

    for (let i = 0; i < positions.length; i += 3) {
      const x = positions[i];
      const y = positions[i + 1];
      const z = positions[i + 2];

      // Apply noise to each vertex
      const offset = Math.sin(time + x * 5) * 0.1;
      positions[i] += offset;
      positions[i + 1] += offset;
      positions[i + 2] += offset;
    }
    geometry.attributes.position.needsUpdate = true;
  }

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);

    // Rotate blob
    blob.rotation.x += 0.01;
    blob.rotation.y += 0.01;

    // Add noise to make it look dynamic
    // addNoiseToBlob();

    renderer.render(scene, camera);
  }

  // Handle window resizing
  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // Start the animation
  animate();
</script>

<style>
  :global(canvas) {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
  /* 
  canvas {
    display: block;
  } */
</style>
